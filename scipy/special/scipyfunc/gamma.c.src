/*
 * float scf_gammaf(float x)
 * double scf_gamma(double x)
 * longdouble scf_gamma(longdouble x)
 *
 * float scf_lngammaf(float x, int* sign)
 * double scf_lngamma(double x, int* sign)
 * longdouble scf_lngamma(longdouble x, int* sign)
 *
 * Gamma function and its logarithm.
 */

/*
 * Parts of the code are copyright:
 *
 *     Copyright John Maddock 2006-7.
 *     Copyright Paul A. Bristow 2007.
 *
 *     Use, modification and distribution are subject to the
 *     Boost Software License, Version 1.0.
 *
 *     ---
 *
 *     Boost Software License - Version 1.0 - August 17th, 2003
 * 
 *     Permission is hereby granted, free of charge, to any person or
 *     organization obtaining a copy of the software and accompanying
 *     documentation covered by this license (the "Software") to use, reproduce,
 *     display, distribute, execute, and transmit the Software, and to prepare
 *     derivative works of the Software, and to permit third-parties to whom the
 *     Software is furnished to do so, all subject to the following:
 *     
 *     The copyright notices in the Software and this entire statement,
 *     including the above license grant, this restriction and the following
 *     disclaimer, must be included in all copies of the Software, in whole or
 *     in part, and all derivative works of the Software, unless such copies or
 *     derivative works are solely in the form of machine-executable object code
 *     generated by a source language processor.
 *     
 *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 *     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
 *     NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 *     DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY,
 *     WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *     SOFTWARE.
 *
 * And the rest are:
 *
 *     Copyright (C) 2009 Pauli Virtanen
 *     Distributed under the same license as Scipy.
 *
 */

#include "scipyfunc.h"

#include "factorials.h"
#include "gamma_lanczos.h"

/**begin repeat
 * #real = float,double,npy_longdouble#
 * #c = f,,l#
 * #C = F,,L#
 * #lanczos = lanczos6m24, lanczos13m53, lanczos24m113#
 */

static @real@ scf_sinpx@c@(@real@ x);
static @real@ scf_is_odd@c@(@real@ x);

@real@ scf_gamma@c@(@real@ z)
{
    @real@ result = 1;
    
    if(z <= 0) {
        if (floor@c@(z) == z) {
            scf_error("scf_gamma@c@", SING);
            return INFINITY@C@;
        }

        if(z <= -20)
        {
            result = scf_gamma@c@(-z) * scf_sinpx@c@(z);
            if ((fabs@c@(result) < 1) && (MAXNUM@C@ * fabs@c@(result) < PI@C@)) {
                scf_error("scf_gamma@c@", OVERFLOW);
                return INFINITY@C@;
            }

            result = -PI@C@ / result;
            if (result == 0) {
                scf_error("scf_gamma@c@", UNDERFLOW);
            }

            return result;
        }

        // shift z to > 1:
        while (z < 0)
        {
            result /= z;
            z += 1;
        }
    }

    if ((floor@c@(z) == z) && (z < MAX_FACTORIAL@C@)) {
        result *= factorials@c@[(int)(trunc@c@(z) - 1)];
    } else {
        result *= @lanczos@_sum@c@(z);
        if(z * log@c@(z) > MAXLOG@C@) {
            /* we're going to overflow unless this is done with care: */
            @real@ zgh, hp;

            zgh = (z + @lanczos@_g@c@() - 0.5@C@);
            if (log@c@(zgh) * z / 2 > MAXNUM@C@) {
                scf_error("scf_gamma@c@", OVERFLOW);
                return INFINITY@C@;
            }

            hp = pow@c@(zgh, (z / 2) - 0.25@C@);
            result *= hp / exp@c@(zgh);
            if (MAXNUM@C@ / hp < result) {
                scf_error("scf_gamma@c@", OVERFLOW);
                return INFINITY@C@;
            }
            result *= hp;
        }
        else
        {
            @real@ zgh = (z + @lanczos@_g() - 0.5@C@);
            result *= pow@c@(zgh, z - 0.5@C@) / exp@c@(zgh);
        }
    }
    return result;
}

/*
 * sin(PI*x)
 */
static @real@ scf_sinpx@c@(@real@ z)
{
    int sign = 1;
    @real@ fl, dist;
    
    if (z < 0) {
        z = -z;
    } else {
        sign = -sign;
    }

    fl = floor@c@(z);
    if (scf_is_odd@c@(fl)) {
        fl += 1;
        dist = fl - z;
        sign = -sign;
    } else {
        dist = z - fl;
    }

    ASSERT(fl >= 0);
    if (dist > 0.5)
        dist = 1 - dist;

    return sign * z * sin@c@(PI@C@ * dist);
}

/*
 * Check whether a float is an odd integer
 */
static @real@ scf_is_odd@c@(@real@ z)
{
    return (z != 2.0@C@ * floor@c@(z/2.0@C@));
}

/* XXX: implement the logarithm */

/**end repeat**/

/*
 * Local Variables:
 * mode:c
 * End:
 */
