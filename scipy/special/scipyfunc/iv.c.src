/*
 * float scf_ivf(float v, float x)
 * double scf_iv(double v, double x)
 * longdouble scf_ivl(longdouble v, longdouble x)
 *
 * Modified Bessel function of noninteger real order, real argument.
 *
 * Returns modified Bessel function of order v of the
 * argument.  If x is negative, v must be integer valued.
 *
 */

/*
 * Parts of the code are copyright:
 *
 *     Cephes Math Library Release 2.8:  June, 2000
 *     Copyright 1984, 1987, 1988, 2000 by Stephen L. Moshier
 *
 * And other parts:
 *
 *     Copyright (c) 2006 Xiaogang Zhang
 *     Use, modification and distribution are subject to the
 *     Boost Software License, Version 1.0.
 *
 *     Boost Software License - Version 1.0 - August 17th, 2003
 * 
 *     Permission is hereby granted, free of charge, to any person or
 *     organization obtaining a copy of the software and accompanying
 *     documentation covered by this license (the "Software") to use, reproduce,
 *     display, distribute, execute, and transmit the Software, and to prepare
 *     derivative works of the Software, and to permit third-parties to whom the
 *     Software is furnished to do so, all subject to the following:
 *     
 *     The copyright notices in the Software and this entire statement,
 *     including the above license grant, this restriction and the following
 *     disclaimer, must be included in all copies of the Software, in whole or
 *     in part, and all derivative works of the Software, unless such copies or
 *     derivative works are solely in the form of machine-executable object code
 *     generated by a source language processor.
 *     
 *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 *     OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
 *     NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR ANYONE
 *     DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY,
 *     WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *     CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *     SOFTWARE.
 *
 * And the rest are:
 *
 *     Copyright (C) 2009 Pauli Virtanen
 *     Distributed under the same license as Scipy.
 *
 */

/*
 * XXX: uses C99 sinf etc. functions; would need to use npy_*?
 */

#include <stdlib.h>
#include <math.h>
#include "scipyfunc.h"

/* Flags for what to compute */
enum {
    need_i = 0x1,
    need_k = 0x2
};

#define MAXITER  500

/**begin repeat
 * #real = float,double,npy_longdouble#
 * #c = f,,l#
 * #C = F,,L#
 */

static @real@ iv_asymptotic@c@(@real@ v, @real@ x);
static void ikv_asymptotic_uniform@c@(@real@ v, @real@ x, @real@ *i, @real@ *k);
static void ikv_temme@c@(@real@ v, @real@ x, @real@ *I, @real@ *K);

@real@ scf_iv@c@(@real@ v, @real@ x)
{
    int sign;
    @real@ t, ax, res;

    /* If v is a negative integer, invoke symmetry */
    t = floor@c@(v);
    if (v < 0.0) {
	if (t == v) {
	    v = -v;		/* symmetry */
	    t = -t;
	}
    }

    /* If x is negative, require v to be an integer */
    sign = 1;
    if (x < 0.0) {
	if (t != v) {
	    scf_error("iv", DOMAIN);
	    return NAN@C@;
	}
	if (v != 2.0 * floor@c@(v / 2.0)) {
	    sign = -1;
        }
    }

    /* Avoid logarithm singularity */
    if (x == 0.0) {
	if (v == 0.0) {
	    return 1.0;
        }
	if (v < 0.0) {
	    scf_error("iv", OVERFLOW);
	    return INFINITY@C@;
	} else
	    return 0.0;
    }

    ax = fabs@c@(x);
    if (fabs@c@(v) > 50) {
        /*
         * Uniform asymptotic expansion for large orders.
         *
         * This appears to overflow slightly later than the Boost
         * implementation of Temme's method.
         */
        ikv_asymptotic_uniform@c@(v, ax, &res, NULL);
    }
    else {
        /* Otherwise: Temme's method */
        ikv_temme@c@(v, ax, &res, NULL);
    }
    res *= sign;
    return res;
}


/*
 * Compute Iv from (AMS5 9.7.1), asymptotic expansion for large |z|
 * Iv ~ exp(x)/sqrt(2 pi x) ( 1 + (4*v*v-1)/8x + (4*v*v-1)(4*v*v-9)/8x/2! + ...)
 */
static @real@ iv_asymptotic@c@(@real@ v, @real@ x)
{
    @real@ mu;
    @real@ sum, term, prefactor, factor;
    int k;

    prefactor = exp@c@(x) / sqrt@c@(2 * PI@C@ * x);

    if (prefactor == INFINITY@C@) {
	return prefactor;
    }

    mu = 4 * v * v;
    sum = 1.0;
    term = 1.0;
    k = 1;

    do {
	factor = (mu - (2 * k - 1) * (2 * k - 1)) / (8 * x) / k;
	if (k > 100) {
	    /* didn't converge */
	    scf_error("iv(iv_asymptotic)", TLOSS);
	    break;
	}
	term *= -factor;
	sum += term;
	++k;
    } while (fabs(term) > EPSILON@C@ * fabs(sum));
    return sum * prefactor;
}


/*
 * Uniform asymptotic expansion factors, (AMS5 9.3.9; AMS5 9.3.10)
 *
 * Computed with:
 * --------------------
import numpy as np
from sympy.mpmath import mpf, mp
mp.dps = 40
t = np.poly1d([mpf('1'), mpf('0')])
def up1(p):
    return mpf('.5')*t*t*(1-t*t)*p.deriv() + 1/mpf('8')*((1-5*t*t)*p).integ()

us = [np.poly1d([mpf('1')])]
for k in range(18):
    us.append(up1(us[-1]))

n = us[-1].order
for p in us:
    print "{"+", ".join(["0"]*(n-p.order) + map(lambda q: "%s@C@"%q, p))+"},"

print "N_UFACTORS", len(us)
print "N_UFACTOR_TERMS", us[-1].order + 1
 * --------------------
 */
#define N_UFACTORS 19
#define N_UFACTOR_TERMS 55
static const @real@ asymptotic_ufactors@c@[N_UFACTORS][N_UFACTOR_TERMS] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.0@C@},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -0.2083333333333333333333333333333333333333@C@, 0.0@C@, 0.125@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.3342013888888888888888888888888888888889@C@, 0.0@C@, -0.4010416666666666666666666666666666666667@C@, 0.0@C@, 0.0703125@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1.025812596450617283950617283950617283951@C@, 0.0@C@, 1.846462673611111111111111111111111111111@C@, 0.0@C@, -0.8912109375@C@, 0.0@C@, 0.0732421875@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4.669584423426247427983539094650205761317@C@, 0.0@C@, -11.20700261622299382716049382716049382716@C@, 0.0@C@, 8.78912353515625@C@, 0.0@C@, -2.3640869140625@C@, 0.0@C@, 0.112152099609375@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -28.21207255820024487740054869684499314129@C@, 0.0@C@, 84.63621767460073463220164609053497942387@C@, 0.0@C@, -91.81824154324001736111111111111111111111@C@, 0.0@C@, 42.53499874538845486111111111111111111111@C@, 0.0@C@, -7.368794359479631696428571428571428571428@C@, 0.0@C@, 0.227108001708984375@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 212.5701300392171228609694120560890108215@C@, 0.0@C@, -765.2524681411816422994898834019204389575@C@, 0.0@C@, 1059.9904525279998779296875@C@, 0.0@C@, -699.5796273761325412326388888888888888889@C@, 0.0@C@, 218.1905117442115904792906746031746031746@C@, 0.0@C@, -26.49143048695155552455357142857142857143@C@, 0.0@C@, 0.5725014209747314453125@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1919.457662318406996310063083863613270335@C@, 0.0@C@, 8061.722181737309384502264952227175735406@C@, 0.0@C@, -13586.55000643413743855040750385802469136@C@, 0.0@C@, 11655.3933368645332477710865162037037037@C@, 0.0@C@, -5305.646978613403108384874131944444444444@C@, 0.0@C@, 1200.9029132163524627685546875@C@, 0.0@C@, -108.0909197883946555001395089285714285714@C@, 0.0@C@, 1.7277275025844573974609375@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20204.29133096614864345123694004355426743@C@, 0.0@C@, -96980.59838863751348856593731220906048367@C@, 0.0@C@, 192547.0012325315323590578202193983624829@C@, 0.0@C@, -203400.1772804155342781658198771326303155@C@, 0.0@C@, 122200.464983017459787704326488353587963@C@, 0.0@C@, -41192.6549688975512981414794921875@C@, 0.0@C@, 7109.514302489363721438816615513392857143@C@, 0.0@C@, -493.9153047730880124228341238839285714286@C@, 0.0@C@, 6.0740420012734830379486083984375@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -242919.1879005513334585317700615421779283@C@, 0.0@C@, 1311763.614662977200676071558332327760813@C@, 0.0@C@, -2998015.918538106750091346203054420251415@C@, 0.0@C@, 3763271.297656403996402105622276302663823@C@, 0.0@C@, -2813563.226586534110707868355618909880294@C@, 0.0@C@, 1268365.273321624781625966231028238932292@C@, 0.0@C@, -331645.1724845635778315010524931408110119@C@, 0.0@C@, 45218.76898136272627328123365129743303571@C@, 0.0@C@, -2499.830481811209624125198884443803267045@C@, 0.0@C@, 24.3805296995560638606548309326171875@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3284469.853072037821137231641040434864073@C@, 0.0@C@, -19706819.11843222692682338984624260918444@C@, 0.0@C@, 50952602.49266464220638182198049918196402@C@, 0.0@C@, -74105148.21153265774833562096441469801543@C@, 0.0@C@, 66344512.2747290266647987984543283834924@C@, 0.0@C@, -37567176.66076335130816319796406192544066@C@, 0.0@C@, 13288767.16642181832943741163169896161115@C@, 0.0@C@, -2785618.128086454688959444562594095865885@C@, 0.0@C@, 308186.4046126623984803907842771020581417@C@, 0.0@C@, -13886.08975371704053197225386446172540838@C@, 0.0@C@, 110.0171402692467381712049245834350585938@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -49329253.66450996197276183127547471301533@C@, 0.0@C@, 325573074.1857657490202280864181331059012@C@, 0.0@C@, -939462359.6815784025462443009203890773859@C@, 0.0@C@, 1553596899.570580056158121044387996170755@C@, 0.0@C@, -1621080552.108337075248175882636768877679@C@, 0.0@C@, 1106842816.823014468259666669096245809838@C@, 0.0@C@, -495889784.275030309254636245374258460892@C@, 0.0@C@, 142062907.7975330951856532785179162466968@C@, 0.0@C@, -24474062.72573872846781300815601586079111@C@, 0.0@C@, 2243768.177922449429230737780239813181819@C@, 0.0@C@, -84005.43360302408528867828125668155563461@C@, 0.0@C@, 551.3358961220205856079701334238052368164@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 814789096.1183121149459306645049764229651@C@, 0.0@C@, -5866481492.051847227610700784435830245348@C@, 0.0@C@, 18688207509.29582492236591930279162694518@C@, 0.0@C@, -34632043388.15877792290241333559550813533@C@, 0.0@C@, 41280185579.75397395513147102709743356438@C@, 0.0@C@, -33026599749.80072314009099267577854354338@C@, 0.0@C@, 17954213731.15560008015220585382803824684@C@, 0.0@C@, -6563293792.619284332035016850974712726703@C@, 0.0@C@, 1559279864.879257513349646204741951632535@C@, 0.0@C@, -225105661.8894152778040714269630529636902@C@, 0.0@C@, 17395107.55397816453810439631423674163902@C@, 0.0@C@, -549842.3275722886871349019329372949741937@C@, 0.0@C@, 3038.09051092238426861058542272076010704@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -14679261247.69561666061242392686689895348@C@, 0.0@C@, 114498237732.0258099527769066295618118372@C@, 0.0@C@, -399096175224.4664979552346232418551237401@C@, 0.0@C@, 819218669548.5773286413033254921621727271@C@, 0.0@C@, -1098375156081.22330682706453541519621885@C@, 0.0@C@, 1008158106865.382094769125164830028196962@C@, 0.0@C@, -645364869245.3765032808836899474691858352@C@, 0.0@C@, 287900649906.1505887229132920572018069653@C@, 0.0@C@, -87867072178.02326567663590419006898931305@C@, 0.0@C@, 17634730606.8349693831519739575843573822@C@, 0.0@C@, -2167164983.223795093518416127711201110744@C@, 0.0@C@, 143157876.718888981291057270117829433347@C@, 0.0@C@, -3871833.442572612620626626666931146869787@C@, 0.0@C@, 18257.75547429317469116938355000456795096@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 286464035717.6790429870109038347210013035@C@, 0.0@C@, -2406297900028.50396109089159221165641095@C@, 0.0@C@, 9109341185239.898955907876541296591202302@C@, 0.0@C@, -20516899410934.43739076047796919585810568@C@, 0.0@C@, 30565125519935.32061172003688280095306301@C@, 0.0@C@, -31667088584785.15840255256788568800234659@C@, 0.0@C@, 23348364044581.84093765746780272027359025@C@, 0.0@C@, -12320491305598.28715978770065317654176647@C@, 0.0@C@, 4612725780849.131966803816033578736862019@C@, 0.0@C@, -1196552880196.181598974160686063231164906@C@, 0.0@C@, 205914503232.4100156890817255326429605818@C@, 0.0@C@, -21822927757.52922372939877564974733791225@C@, 0.0@C@, 1247009293.512710324825868373805287154193@C@, 0.0@C@, -29188388.12222081340342732031993895285344@C@, 0.0@C@, 118838.4262567832531237721482852975896094@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 0, 0, 0, -6019723417234.005444990937465304623263503@C@, 0.0@C@, 54177510755106.04900491843718774160937153@C@, 0.0@C@, -221349638702525.195965593797940754625125@C@, 0.0@C@, 542739664987659.7227020591239685814347772@C@, 0.0@C@, -889496939881026.4418128257191774092176472@C@, 0.0@C@, 1026955196082762.488813740580594021528777@C@, 0.0@C@, -857461032982895.0513961987089197639950746@C@, 0.0@C@, 523054882578444.6555790535196170039264167@C@, 0.0@C@, -232604831188939.9252321748606017756390492@C@, 0.0@C@, 74373122908679.14494114728953717075546608@C@, 0.0@C@, -16634824724892.48051865692506018647877511@C@, 0.0@C@, 2485000928034.0853236474523656379664871@C@, 0.0@C@, -229619372968.2464681659534773231422359726@C@, 0.0@C@, 11465754899.44823715692235895954002352319@C@, 0.0@C@, -234557963.5222515247762632483406069812548@C@, 0.0@C@, 832859.3040162892989757698058994606071792@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, 0, 0, 0, 135522158703093.6902915277458009335107109@C@, 0.0@C@, -1301012723549699.426798666359688961702825@C@, 0.0@C@, 5705782159023670.809618694505693765310684@C@, 0.0@C@, -15129826322457681.18084636116034478297714@C@, 0.0@C@, 27054711306197081.24101419805879395734064@C@, 0.0@C@, -34447226006485144.6977970830988029325329@C@, 0.0@C@, 32138275268586241.20000619279550618003865@C@, 0.0@C@, -22268225133911142.56219382687736836083564@C@, 0.0@C@, 11486706978449752.10969241162584643997771@C@, 0.0@C@, -4379325838364015.437780098517928750420907@C@, 0.0@C@, 1212675804250347.416525907257338234858255@C@, 0.0@C@, -236652530451649.2516817769490479771007867@C@, 0.0@C@, 31007436472896.46141719069923627259598387@C@, 0.0@C@, -2521558474912.854621312538497418401214556@C@, 0.0@C@, 110997405139.1790127937406706965331519261@C@, 0.0@C@, -2001646928.191776331529938815671142130527@C@, 0.0@C@, 6252951.493434797002466521745854544089838@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{0, 0, 0, -3254192619642668.832809062072577807854007@C@, 0.0@C@, 33192764720355222.09465243314029364011087@C@, 0.0@C@, -155529835043139025.6212648930015349075645@C@, 0.0@C@, 443479546141719040.6002566704378016618@C@, 0.0@C@, -859257798031754799.0581328866810681781981@C@, 0.0@C@, 1196199114275630785.068459026679820257072@C@, 0.0@C@, -1233611693196069502.238697805757509054439@C@, 0.0@C@, 957533509816913866.3533895519883677937673@C@, 0.0@C@, -562631788074636028.3949116996609716044233@C@, 0.0@C@, 249603651261604257.0994262490257147891088@C@, 0.0@C@, -82709456515850642.78725937951200775370302@C@, 0.0@C@, 20064271476309530.80010052087140458567218@C@, 0.0@C@, -3450385511846272.492011831924964664851297@C@, 0.0@C@, 400044457043036.2415133450812654903881769@C@, 0.0@C@, -28863837631414.76025414316301471394633032@C@, 0.0@C@, 1128709145410.874078578624908477650898808@C@, 0.0@C@, -18078220384.65806371713485435332553930938@C@, 0.0@C@, 50069589.53198892599769148662673234201348@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
{83019576067319104.6444182247728704174977@C@, 0.0@C@, -896611421527046330.1597168275470005089752@C@, 0.0@C@, 4470200964012310169.294212039718634430927@C@, 0.0@C@, -13639420410571590656.82587128977512475789@C@, 0.0@C@, 28465212251676570976.50533573844959871783@C@, 0.0@C@, -43015557038314437423.43849559927269067357@C@, 0.0@C@, 48599427293248357751.53498734270615660989@C@, 0.0@C@, -41788614446568388817.54858156644904120882@C@, 0.0@C@, 27572829816505188649.47605602180671918913@C@, 0.0@C@, -13970803516443373854.72472411321626079753@C@, 0.0@C@, 5402894876715981887.22186129704639123783@C@, 0.0@C@, -1573643476518959871.900805130320975075745@C@, 0.0@C@, 337667624979060962.2988679489577904173639@C@, 0.0@C@, -51605093193485227.43652109163378487372325@C@, 0.0@C@, 5335106978708838.67550669095248947033174@C@, 0.0@C@, -343965304743075.9474698419168725856245321@C@, 0.0@C@, 12030115826419.19172809950344616876955295@C@, 0.0@C@, -172283238717.3504987359310146915852183526@C@, 0.0@C@, 425939216.5047669051886949383176883261563@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@, 0.0@C@},
};


/*
 * Compute Iv, Kv from (AMS5 9.7.7 + 9.7.8), asymptotic expansion for large v
 */
void ikv_asymptotic_uniform@c@(@real@ v, @real@ x,
                               @real@ *i_value, @real@ *k_value)
{
    @real@ i_prefactor, k_prefactor;
    @real@ t, t2, eta, z;
    @real@ i_sum, k_sum, term, divisor;
    int k, n;
    int sign = 1;

    if (v < 0) {
	/* Negative v; compute I_{-v} and K_{-v} and use (AMS 9.6.2) */
	sign = -1;
	v = -v;
    }

    z = x / v;
    t = 1 / sqrt@c@(1 + z * z);
    t2 = t * t;
    eta = sqrt@c@(1 + z * z) + log(z / (1 + 1 / t));

    i_prefactor = sqrt@c@(t / (2 * PI@C@ * v)) * exp(v * eta);
    i_sum = 1.0;

    k_prefactor = sqrt@c@(PI@C@ * t / (2 * v)) * exp(-v * eta);
    k_sum = 1.0;

    divisor = v;
    for (n = 1; n < N_UFACTORS; ++n) {
	/*
         * Evaluate u_k(t) with Horner's scheme;
	 * (using the knowledge about which coefficients are zero)
	 */
	term = 0;
	for (k = N_UFACTOR_TERMS - 1 - 3 * n;
	     k < N_UFACTOR_TERMS - n; k += 2) {
	    term *= t2;
	    term += asymptotic_ufactors@c@[n][k];
	}
	for (k = 1; k < n; k += 2) {
	    term *= t2;
        }
	if (n % 2 == 1) {
	    term *= t;
        }

	/* Sum terms */
	term /= divisor;
	i_sum += term;
        k_sum += (n % 2 == 0) ? term : -term;

	/* Check convergence */
	if (fabs(term) < EPSILON@C@) {
	    break;
        }

	divisor *= v;
    }

    if (fabs(term) > 1e-3*fabs(i_sum)) {
	/* Didn't converge */
	scf_error("ikv_asymptotic_uniform", TLOSS);
    }
    if (fabs(term) > EPSILON@C@*fabs(i_sum)) {
	/* Some precision lost */
	scf_error("ikv_asymptotic_uniform", PLOSS);
    }

    if (k_value != NULL) {
        /* symmetric in v */
        *k_value = k_prefactor * k_sum;
    }

    if (i_value != NULL) {
        if (sign == 1) {
            *i_value = i_prefactor * i_sum;
        }
        else {
            /* (AMS 9.6.2) */
            *i_value = (i_prefactor * i_sum
                        + (2/PI@C@) * sin@c@(PI@C@*v) * k_prefactor * k_sum);
        }
    }
}


/*
 * The following code originates from the Boost C++ library,
 * from file `boost/math/special_functions/detail/bessel_ik.hpp`,
 * converted from C++ to C.
 */

#ifdef DEBUG
#define BOOST_ASSERT(a) assert(a)
#else
#define BOOST_ASSERT(a)
#endif

/*
 * Modified Bessel functions of the first and second kind of fractional order
 *
 * Calculate K(v, x) and K(v+1, x) by method analogous to
 * Temme, Journal of Computational Physics, vol 21, 343 (1976)
 */
static int temme_ik_series@c@(@real@ v, @real@ x, @real@ *K, @real@ *K1)
{
    @real@ f, h, p, q, coef, sum, sum1, tolerance;
    @real@ a, b, c, d, sigma, gamma1, gamma2;
    unsigned long k;

    /*
     * |x| <= 2, Temme series converge rapidly
     * |x| > 2, the larger the |x|, the slower the convergence
     */
    BOOST_ASSERT(fabs(x) <= 2);
    BOOST_ASSERT(fabs(v) <= 0.5f);

    @real@ gp = scf_gamma@c@(v + 1) - 1;
    @real@ gm = scf_gamma@c@(-v + 1) - 1;

    a = log@c@(x / 2);
    b = exp@c@(v * a);
    sigma = -a * v;
    c = fabs(v) < EPSILON@C@ ? 1 : sin@c@(PI@C@ * v) / (v * PI@C@);
    d = fabs(sigma) < EPSILON@C@ ? 1 : sinh@c@(sigma) / sigma;
    gamma1 = fabs(v) < EPSILON@C@ ? -EULER@C@ : (0.5@C@ / v) * (gp - gm) * c;
    gamma2 = (2 + gp + gm) * c / 2;

    /* initial values */
    p = (gp + 1) / (2 * b);
    q = (1 + gm) * b / 2;
    f = (cosh@c@(sigma) * gamma1 + d * (-a) * gamma2) / c;
    h = p;
    coef = 1;
    sum = coef * f;
    sum1 = coef * h;

    /* series summation */
    tolerance = EPSILON@C@;
    for (k = 1; k < MAXITER; k++) {
	f = (k * f + p + q) / (k * k - v * v);
	p /= k - v;
	q /= k + v;
	h = p - k * f;
	coef *= x * x / (4 * k);
	sum += coef * f;
	sum1 += coef * h;
	if (fabs(coef * f) < fabs(sum) * tolerance) {
	    break;
	}
    }
    if (k == MAXITER) {
	scf_error("ikv_temme@c@(temme_ik_series)", TLOSS);
    }

    *K = sum;
    *K1 = 2 * sum1 / x;

    return 0;
}

/* Evaluate continued fraction fv = I_(v+1) / I_v, derived from
 * Abramowitz and Stegun, Handbook of Mathematical Functions, 1972, 9.1.73 */
static int CF1_ik@c@(@real@ v, @real@ x, @real@ *fv)
{
    @real@ C, D, f, a, b, delta, tiny, tolerance;
    unsigned long k;


    /*
     * |x| <= |v|, CF1_ik converges rapidly
     * |x| > |v|, CF1_ik needs O(|x|) iterations to converge
     */

    /*
     * modified Lentz's method, see
     * Lentz, Applied Optics, vol 15, 668 (1976)
     */
    tolerance = 2 * EPSILON@C@;
    tiny = 1 / sqrt@c@(MAXNUM@C@);
    C = f = tiny;		/* b0 = 0, replace with tiny */
    D = 0;
    for (k = 1; k < MAXITER; k++) {
	a = 1;
	b = 2 * (v + k) / x;
	C = b + a / C;
	D = b + a * D;
	if (C == 0) {
	    C = tiny;
	}
	if (D == 0) {
	    D = tiny;
	}
	D = 1 / D;
	delta = C * D;
	f *= delta;
	if (fabs(delta - 1) <= tolerance) {
	    break;
	}
    }
    if (k == MAXITER) {
	scf_error("ikv_temme@c@(CF1_ik)", TLOSS);
    }

    *fv = f;

    return 0;
}

/*
 * Calculate K(v, x) and K(v+1, x) by evaluating continued fraction
 * z1 / z0 = U(v+1.5, 2v+1, 2x) / U(v+0.5, 2v+1, 2x), see
 * Thompson and Barnett, Computer Physics Communications, vol 47, 245 (1987)
 */
static int CF2_ik@c@(@real@ v, @real@ x, @real@ *Kv, @real@ *Kv1)
{

    @real@ S, C, Q, D, f, a, b, q, delta, tolerance, current, prev;
    unsigned long k;

    /*
     * |x| >= |v|, CF2_ik converges rapidly
     * |x| -> 0, CF2_ik fails to converge
     */

    BOOST_ASSERT(fabs(x) > 1);

    /*
     * Steed's algorithm, see Thompson and Barnett,
     * Journal of Computational Physics, vol 64, 490 (1986)
     */
    tolerance = EPSILON@C@;
    a = v * v - 0.25f;
    b = 2 * (x + 1);		/* b1 */
    D = 1 / b;			/* D1 = 1 / b1 */
    f = delta = D;		/* f1 = delta1 = D1, coincidence */
    prev = 0;			/* q0 */
    current = 1;		/* q1 */
    Q = C = -a;			/* Q1 = C1 because q1 = 1 */
    S = 1 + Q * delta;		/* S1 */
    for (k = 2; k < MAXITER; k++)	/* starting from 2 */
    {
	/* continued fraction f = z1 / z0 */
	a -= 2 * (k - 1);
	b += 2;
	D = 1 / (b + a * D);
	delta *= b * D - 1;
	f += delta;

	/* series summation S = 1 + \sum_{n=1}^{\infty} C_n * z_n / z_0 */
	q = (prev - (b - 2) * current) / a;
	prev = current;
	current = q;		/* forward recurrence for q */
	C *= -a / k;
	Q += C * q;
	S += Q * delta;

	/* S converges slower than f */
	if (fabs(Q * delta) < fabs(S) * tolerance) {
	    break;
	}
    }
    if (k == MAXITER) {
	scf_error("ikv_temme@c@(CF2_ik)", TLOSS);
    }

    *Kv = sqrt@c@(PI@C@ / (2 * x)) * exp(-x) / S;
    *Kv1 = *Kv * (0.5f + v + x + (v * v - 0.25f) * f) / x;

    return 0;
}

/*
 * Compute I(v, x) and K(v, x) simultaneously by Temme's method, see
 * Temme, Journal of Computational Physics, vol 19, 324 (1975)
 */
void ikv_temme@c@(@real@ v, @real@ x, @real@ *I, @real@ *K)
{
    /* Kv1 = K_(v+1), fv = I_(v+1) / I_v */
    /* Ku1 = K_(u+1), fu = I_(u+1) / I_u */
    @real@ u, Iv, Kv, Kv1, Ku, Ku1, fv;
    @real@ W, current, prev, next;
    int reflect = 0;
    unsigned n, k;
    int kind;

    kind = 0;
    if (I != NULL) {
	kind |= need_i;
    }
    if (K != NULL) {
	kind |= need_k;
    }

    if (v < 0) {
	reflect = 1;
	v = -v;			/* v is non-negative from here */
	kind |= need_k;
    }
    n = (unsigned)round@c@(v);
    u = v - n;			/* -1/2 <= u < 1/2 */

    if (x < 0) {
        if (I != NULL) *I = NAN@C@;
        if (K != NULL) *K = NAN@C@;
	scf_error("ikv_temme", DOMAIN);
	return;
    }
    if (x == 0) {
	Iv = (v == 0) ? 1 : 0;
	if (kind & need_k) {
	    scf_error("ikv_temme", OVERFLOW);
	    Kv = INFINITY@C@;
	}
        else {
	    Kv = NAN@C@;		/* any value will do */
	}

	if (reflect && (kind & need_i)) {
	    @real@ z = (u + n % 2);
	    Iv = sin@c@(PI@C@ * z) == 0 ? Iv : INFINITY@C@;
            if (Iv == INFINITY@C@ || Iv == -INFINITY@C@) {
		scf_error("ikv_temme", OVERFLOW);
            }
	}

	if (I != NULL) {
            *I = Iv;
        }
	if (K != NULL) {
            *K = Kv;
        }
	return;
    }
    /* x is positive until reflection */
    W = 1 / x;			/* Wronskian */
    if (x <= 2) {		/* x in (0, 2] */
	temme_ik_series@c@(u, x, &Ku, &Ku1);	/* Temme series */
    }
    else {		                 	/* x in (2, \infty) */
	CF2_ik@c@(u, x, &Ku, &Ku1);	/* continued fraction CF2_ik */
    }
    prev = Ku;
    current = Ku1;
    for (k = 1; k <= n; k++) {	/* forward recurrence for K */
	next = 2 * (u + k) * current / x + prev;
	prev = current;
	current = next;
    }
    Kv = prev;
    Kv1 = current;
    if (kind & need_i) {
	@real@ lim = (4 * v * v + 10) / (8 * x);
	lim *= lim;
	lim *= lim;
	lim /= 24;
	if ((lim < EPSILON@C@ * 10) && (x > 100)) {
	    /*
             * x is huge compared to v, CF1 may be very slow 
	     * to converge so use asymptotic expansion for large
	     * x case instead.  Note that the asymptotic expansion
	     * isn't very accurate - so it's deliberately very hard
	     * to get here - probably we're going to overflow:
             */
	    Iv = iv_asymptotic@c@(v, x);
	}
        else {
	    CF1_ik@c@(v, x, &fv);	/* continued fraction CF1_ik */
	    Iv = W / (Kv * fv + Kv1);	/* Wronskian relation */
	}
    }
    else {
	Iv = NAN@C@;		/* any value will do */
    }

    if (reflect) {
	@real@ z = (u + n % 2);
	if (I != NULL) {
            /* reflection formula */
            *I = Iv + (2 / PI@C@) * sin@c@(PI@C@ * z) * Kv;
        }
	if (K != NULL) {
            *K = Kv;
        }
    } else {
	if (I != NULL) {
            *I = Iv;
        }
	if (K != NULL) {
            *K = Kv;
        }
    }
    return;
}

/**end repeat**/

/*
 * Local Variables:
 * mode:c
 * End:
 */
